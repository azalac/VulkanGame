/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   ShipController.hpp
 * Author: austin-z
 *
 * Created on April 11, 2019, 4:58 PM
 */

#ifndef SHIPCONTROLLER_HPP
#define SHIPCONTROLLER_HPP

#include "ControllerHelpers.hpp"

enum class PlayerState {
    // The ship is idle
    eIdle,
    // The ship is turning
    eTurning,
    // The ship is moving
    eMoving
};

/**
 Sent from the ship state change event.
 */
struct ShipStateChangeArguments {
    void * sender;
    const PlayerState state;
    bool paused;

    ShipStateChangeArguments(void * sender, const PlayerState state, bool paused) :
    sender(sender), state(state), paused(paused) {

    }
};

/**
 * Controls an actor via setting a target. The actor must first rotate to face the
 * target, then it can start moving. player state change sent when the internal
 * state chances (see above enum class).
 */
class ShipControllerDecorator : public ObjectDecorator {
private:

    glm::vec2 target = {0, 0};

    double shipspeed = DEFAULT_SHIP_SPEED;
    double rotationspeed = 1;

    bool target_reached = true;

    EventIn onkey;
    EventOut playerstatechange;
    bool statechanged = false;
    PlayerState state = PlayerState::eIdle;

    bool paused = false;

public:

    static constexpr double DEFAULT_SHIP_SPEED = 0.1;

    ShipControllerDecorator(EventOut playerstatechange = EventManager::NULL_EVENT) {
        this->playerstatechange = playerstatechange;
        setState(PlayerState::eIdle);
    }

    void setTarget(glm::vec2 target) {
        this->target = target;
        setState(PlayerState::eTurning);
    }

    virtual double getSpeed() {
        return shipspeed;
    }

    bool isMoving() {
        return state == PlayerState::eMoving && !paused;
    }

    virtual void Apply(Scene * scene, ObjectHandle object, double deltat) {
        if (statechanged) {
            scene->dispatchEvent(playerstatechange, ShipStateChangeArguments(this, state, paused));
            statechanged = false;
        }

        if (state == PlayerState::eIdle || paused) {
            return;
        }

        GameObject & owner = (*scene)[object];

        // get the direction unit vector
        glm::vec2 direction = target - owner.getPosition();

        double length = glm::length(direction);

        // normalize the vector and scale it
        double k = getSpeed() * deltat / length;
        direction = {direction.x * k, direction.y * k};

        double target_rotation = atan2(direction.x, -direction.y) - M_PI_2;

        double current_rotation = (double) owner.getRotation();

        double delta = handleTurn(current_rotation, target_rotation);

        owner.deltaRotation((float) (delta * deltat));

        if (abs(delta) > M_PI_4 / 2) {
            setState(PlayerState::eTurning);
        }

        if (abs(delta) < M_PI_4 / 2) {
            setState(PlayerState::eMoving);
        }

        if (state == PlayerState::eMoving) {
            owner.deltaPosition(direction);
        }

        if (length <= 0.01) {
            setState(PlayerState::eIdle);
        }

    }

    bool isPaused() {
        return paused;
    }

protected:

    void setState(PlayerState newstate) {
        statechanged = state != newstate;
        state = newstate;
    }

    void setPaused(bool paused) {
        statechanged = this->paused != paused;
        this->paused = paused;
    }

private:

    /**
     * Gets the amount to turn by without any time scaling.
     * @param current The current rotation
     * @param target The target rotation
     * @return The delta rotation
     */
    double handleTurn(double current, double target) {
        double delta = fmod(target - current, 2 * M_PI);

        if (delta < -M_PI) {
            delta += 2 * M_PI;
        }

        if (delta >= M_PI) {
            delta -= 2 * M_PI;
        }

        double adelta = abs(delta);

        if (adelta > rotationspeed) {
            delta = signum(delta) * rotationspeed;
        }

        return delta;
    }

};

/**
 * A ship controller which responsed to mouse click events
 */
class PlayerShipController : public ShipControllerDecorator, public EventHandler {
private:

    EventIn onpause, onunpause, onclick;

public:

    /**
     * @param playerstatechange Sent when the state changes.
     * @param onpause Received when the ship should paused (on menu open)
     * @param onunpause Received when the ship should continue (on menu close)
     * @param onclick Received when the ship should change its target
     */
    PlayerShipController(
            EventOut playerstatechange = EventManager::NULL_EVENT,
            EventIn onpause = EventManager::NULL_EVENT,
            EventIn onunpause = EventManager::NULL_EVENT,
            EventIn onclick = EventManager::NULL_EVENT
            ) : ShipControllerDecorator(playerstatechange),
    onpause(onpause), onunpause(onunpause), onclick(onclick) {

    }

    virtual void RegisterHooks(EventManager * events) override {
        events->addHandler(onpause, this);
        events->addHandler(onunpause, this);
        events->addHandler(onclick, this);
    }

    virtual void OnEvent(EventManager * manager, Event id, const std::shared_ptr<void> arguments) override {
        if (id == onpause) {
            setPaused(true);
        }
        if (id == onunpause) {
            setPaused(false);
        }
        if (id == onclick && !isPaused()) {
            setTarget(*reinterpret_cast<glm::vec2*> (arguments.get()));
        }
    }

};

/**
 * A ship controller which follows the AI rules from the assignment specification.
 */
class AIShipController : public ShipControllerDecorator, public EventHandler {
private:

    ObjectHandle player;
    Event playerstatechange;

    bool playerismoving = false;

    double playerdistance;

    const double SPEED_BOOST_DISTANCE = 0.2;

public:

    /**
     * @param playerstatechange Received when the player changes state
     * @param player The player object handle
     */
    AIShipController(EventIn playerstatechange, ObjectHandle player) {
        this->playerstatechange = playerstatechange;
        this->player = player;
    }

    virtual void RegisterHooks(EventManager * events) override {
        events->addHandler(playerstatechange, this);
    }

    virtual double getSpeed() override {
        double scalar = playerdistance < SPEED_BOOST_DISTANCE ? 1 : 0.5;
        return playerismoving ? ShipControllerDecorator::getSpeed() * scalar : 0;
    }

    virtual void Apply(Scene * scene, ObjectHandle object, double deltat) override {
        glm::vec2 p = (*scene)[player].getPosition();
        playerdistance = glm::distance(p, (*scene)[object].getPosition());
        setTarget(p);

        ShipControllerDecorator::Apply(scene, object, deltat);
    }

    virtual void OnEvent(EventManager * manager, Event id, const std::shared_ptr<void> arguments) override {
        if (id == playerstatechange) {
            const ShipStateChangeArguments * state = reinterpret_cast<ShipStateChangeArguments*> (arguments.get());
            playerismoving = state->state == PlayerState::eMoving;

            setPaused(state->paused);

            if (!playerismoving) {
                setState(PlayerState::eIdle);
            }
        }
    }

};


#endif /* SHIPCONTROLLER_HPP */

